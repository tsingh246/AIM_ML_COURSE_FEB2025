def solve_equations(X, y):
        """
        Solve the linear system X·β = y via Gaussian elimination (with partial pivoting).

        Parameters
        ----------
        X : list of list of floats
            Coefficient matrix of shape (n, n).
        y : list of floats
            Right‐hand‐side vector of length n.

        Returns
        -------
        beta : list of floats
            Solution vector β such that X·β = y.

        Raises
        ------
        ValueError
            If the matrix is singular or input sizes are inconsistent.
        """
        # Number of equations
        n = len(X)
        if any(len(row) != n for row in X):
            raise ValueError(f"All rows of X must have length {n}")
        if len(y) != n:
            raise ValueError(f"Length of y must be {n}")

        # Build augmented matrix A = [X | y]
        # and convert all entries to float
        A = [list(map(float, X[i])) + [float(y[i])] for i in range(n)]

        # Forward elimination
        for i in range(n):
            # Partial pivoting: find row with max abs value in column i
            pivot_row = max(range(i, n), key=lambda r: abs(A[r][i]))
            if abs(A[pivot_row][i]) < 1e-12:
                raise ValueError("Matrix is singular or nearly singular")
            # Swap current row with pivot_row
            A[i], A[pivot_row] = A[pivot_row], A[i]

            # Eliminate entries below A[i][i]
            for r in range(i + 1, n):
                factor = A[r][i] / A[i][i]
                # subtract factor * row i from row r
                for c in range(i, n + 1):
                    A[r][c] -= factor * A[i][c]

        # Back substitution
        beta = [0.0] * n
        for i in range(n - 1, -1, -1):
            rhs = A[i][n]  # the augmented value
            for j in range(i + 1, n):
                rhs -= A[i][j] * beta[j]
            beta[i] = rhs / A[i][i]

        return beta